#!/opt/anaconda/envs/bd9/bin/python
#!/usr/bin/python3 # нужна ли эта директива, если есть верхняя? Укажывает ли верхняя на окружение с Python3?
# Директтива "#!" в первой строке - не часть python, интерпретатор python рассматривает всё
# что начинается с "#" как комментарий. Но эта директива важна для оболочки (bash), которая поймет,
# что при запуске этого файла как исполлняемый файл, нужно будет передать этот файл в качестве аргумента интерпретатору
# Например, если мы выполним команду
# python mapper.py
# то эти комментарии вообще теряют весь смысл и учитываться интерпретатором python не будут. При этом будет использован
# текущий python, то есть путь к которому прописан в переменной PATH (или первый из них, который найдется в PATH)
# Если мы сделаем файл mapper.py исполняемым и выполним команду
# ./mapper.py
# то оболочка (bash) посмотрит первую строку, и если она начинается с "#!", то использует то, что указано дальше, как
# команду, на вход которой подастся исполняемый файл. То есть в нашем случае при исполнении "./mapper.py" на самом деле
# оболочка исполнит
# /opt/anaconda/envs/bd9/bin/python mapper.py
# Но в том и другом случае второй комментарий "#!/usr/bin/python3" останется без внимания и ни на что не повлияет
# Если же мы попытаемся выполнить "./mapper.py", но в нем не будет первой строки "#!...", то bash поругается, что
# не знает как это запускать

import sys
import happybase

connection = happybase.Connection('bd-node2.newprolab.com')
table = connection.table('semen.shafronov')

    
def map(line):
    # Наверное, при оформлении забыл что-то поправить и оставили i вместо line. Переменной i не существует :)
    objects = i.split('\t')
    if len(objects) != 3:
        return
    uid, timestamp, url = objects
    # Тут неплохо было бы проверить, что uid является "натуральным числом, записанным в десятичной форме", как указано
    # в задании. Иначе при приведении к int может возникнуть исключение
    if len(uid) < 11:
        return
    # Следуя guidelines, следовало бы число 256 вынести в константу, а число 25 можно было бы вынести в параметр функции
    # (мне у себя тоже следовало так сделать :) )
    # Еще вот это выражение "int(uid) % 256 != 25" можно вынести в функцию, название которой бы намекало на
    # то что здесь происходит. Например, is_multiple_of_number(multiple=uid, number=256, offset=25). Поучилось бы
    # if not is_multiple_of_number(multiple=uid, number=256, offset=25):
    #     return
    # Можно было бы придумать название получше, я сейчас не смог придумать :)
    # Или назвать filter_uid_by_number
    if int(uid) % 256 != 25:
        return
    if url.startswith('http'):
        # Потенциально, при преобразовании timestamp к float может возникнуть исключение при неверном формате.
        # Желательно проверять формат строки или обрабатывать исключение в блоке try/catch
        timestamp = int(float(timestamp) * 1000)
        sys.stdout.write('{}\t{}\t{}\n'.format(uid, timestamp, url))
        table.put(uid, {'data:url': url}, timestamp)

def main():
    for line in sys.stdin:
        map(line.strip())
        
# Да, в принципе можно было обойтись и без этой проверки и программа всё равно бы отработала
# Разница в том, что если бы мы в другом скрипте сделали import этого файла "import mapper", то
# наличие этой проверки гарантирует, что при импорте этот код не запустится, т.к. в переменной __name__
# в этом случае будет что-то другое. Если же бы мы обошлись без этой проверки и сделали импорт этого файла,
# то всё что мы тут написали исполнилось бы, а, скорее всего, мы этого не хотели :)
# Принято делать такую проверку. Но так как эта программа самодостаточна и не подразумевается, что ее кто-нибудь
# будет импортировать, то ничего бы страшного не случилось, если бы мы опустили эту проверку
if __name__ == '__main__': # не знаю, зачем запускаю этот запрос. Можно ли сразу запустить цикл с for line in sys.stdin...?
    main()
